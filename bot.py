import os
import sys
import json
import asyncio
import hmac
import hashlib
import time
from datetime import datetime, timezone, timedelta
from typing import Dict, List, Optional, Tuple
import aiohttp
from telegram import Update, InlineKeyboardButton, InlineKeyboardMarkup, BotCommand
from telegram.ext import Application, CommandHandler, CallbackQueryHandler, ContextTypes, ConversationHandler, MessageHandler, filters
from aiohttp import web
from dotenv import load_dotenv

load_dotenv()

TELEGRAM_TOKEN = os.getenv('TELEGRAM_TOKEN')
HYPERLIQUID_API = os.getenv('HYPERLIQUID_API', 'https://api.hyperliquid.xyz')
RAPIDAPI_KEY = os.getenv('RAPIDAPI_KEY')
RAPIDAPI_HOST = os.getenv('RAPIDAPI_HOST', 'twitter241.p.rapidapi.com')
MEXC_ACCESS_KEY = os.getenv('MEXC_ACCESS_KEY')
MEXC_SECRET_KEY = os.getenv('MEXC_SECRET_KEY')
ETHERSCAN_API_KEY = os.getenv('ETHERSCAN_API_KEY')
TETHER_MULTISIG = '0xC6CDE7C39eB2f0F0095F41570af89eFC2C1Ea828'
TETHER_TREASURY = '0x5754284f345afc66a98fbB0a0Afe71e0F007B949'

WHALES_FILE = os.path.join(os.path.dirname(__file__), 'whales.json')
TETHER_FILE = os.path.join(os.path.dirname(__file__), 'tether_last.json')
X_FILE = os.path.join(os.path.dirname(__file__), 'x_accounts.json')
X_LAST_FILE = os.path.join(os.path.dirname(__file__), 'x_last.json')
X_USER_IDS = os.path.join(os.path.dirname(__file__), 'x_user_ids.json')
MEXC_LAST_FILE = os.path.join(os.path.dirname(__file__), 'mexc_last.json')

if not TELEGRAM_TOKEN:
    raise ValueError("Ë´ãÂú® .env Êñá‰ª∂‰∏≠Ë®≠ÁΩÆ TELEGRAM_TOKEN")

ADD_ADDRESS, ADD_NAME = range(2)
BATCH_ADD_DATA = range(1)
ADD_X = range(1)

class WhaleTracker:
    def __init__(self):
        self.whales: Dict[str, str] = self.load_whales()
        self.last_positions: Dict[str, Dict] = {}
        self.subscribed_chats = set()
        
    def load_whales(self) -> Dict[str, str]:
        if os.path.exists(WHALES_FILE):
            try:
                with open(WHALES_FILE, 'r', encoding='utf-8') as f:
                    return json.load(f)
            except:
                return {}
        return {}
    
    def save_whales(self):
        with open(WHALES_FILE, 'w', encoding='utf-8') as f:
            json.dump(self.whales, f, ensure_ascii=False, indent=2)
    
    def add_whale(self, address: str, name: str = '') -> bool:
        if address not in self.whales:
            self.whales[address] = name or address[:8]
            self.save_whales()
            return True
        return False
    
    def remove_whale(self, address: str) -> bool:
        if address in self.whales:
            del self.whales[address]
            self.save_whales()
            if address in self.last_positions:
                del self.last_positions[address]
            return True
        return False
    
    async def fetch_positions(self, address: str) -> List[Dict]:
        async with aiohttp.ClientSession() as session:
            try:
                async with session.post(
                    f'{HYPERLIQUID_API}/info',
                    json={'type': 'clearinghouseState', 'user': address},
                    timeout=aiohttp.ClientTimeout(total=10)
                ) as resp:
                    if resp.status == 200:
                        data = await resp.json()
                        return data.get('assetPositions', [])
            except Exception as e:
                print(f"Error fetching positions for {address}: {e}")
        return []
    
    def format_position(self, pos: Dict) -> str:
        position = pos.get('position', {})
        coin = position.get('coin', 'UNKNOWN')
        szi = float(position.get('szi', '0'))
        entry_px = float(position.get('entryPx', '0'))
        leverage = float(position.get('leverage', {}).get('value', '1'))
        liquidation_px = float(position.get('liquidationPx') or '0')
        
        unrealized_pnl = float(position.get('unrealizedPnl', '0'))
        position_value = abs(szi * entry_px)
        margin = position_value / leverage if leverage > 0 else position_value
        
        pnl_percent = (unrealized_pnl / margin * 100) if margin > 0 else 0
        
        direction = "üü¢ ÂÅöÂ§ö" if szi > 0 else "üî¥ ÂÅöÁ©∫"
        pnl_emoji = "üí∞" if unrealized_pnl > 0 else "üí∏" if unrealized_pnl < 0 else "‚ûñ"
        
        return f"""
{'‚ïê' * 30}
ü™ô Âπ£Á®Æ: <b>{coin}</b>
üìä ÊñπÂêë: {direction} | ÊßìÊ°ø: <b>{leverage:.1f}x</b>
üì¶ ÊåÅÂÄâÈáè: ${position_value:,.2f} USDT
üíµ ‰øùË≠âÈáë: ${margin:,.2f} USDT
üìç ÈñãÂÄâÂÉπ: ${entry_px:,.4f}
{pnl_emoji} ÁõàËôß: ${unrealized_pnl:,.2f} USDT ({pnl_percent:+.2f}%)
‚ö†Ô∏è Âº∑Âπ≥ÂÉπ: ${liquidation_px:,.4f}
"""
    
    def positions_changed(self, address: str, new_positions: List) -> Tuple[bool, float]:
        if address not in self.last_positions:
            new_margins = {}
            for p in new_positions:
                coin = p['position']['coin']
                margin = float(p['position'].get('marginUsed', '0'))
                new_margins[coin] = margin
            self.last_positions[address] = new_margins
            return False, 0.0
        
        old_pos_dict = self.last_positions[address]
        old_total = sum(old_pos_dict.values())
        new_total = sum(float(p['position'].get('marginUsed', '0')) for p in new_positions)
        
        margin_diff = new_total - old_total
        
        if old_total > 0:
            margin_change_percent = abs(margin_diff / old_total * 100)
        else:
            margin_change_percent = 0
        
        if margin_change_percent >= 10:
            return True, margin_diff
        
        return False, 0.0

class TetherTracker:
    def __init__(self):
        self.last_tx_hash = self.load_last_tx()
        self.cached_mints = []
        self.cache_time = 0
    
    def load_last_tx(self) -> str:
        if os.path.exists(TETHER_FILE):
            try:
                with open(TETHER_FILE, 'r') as f:
                    data = json.load(f)
                    return data.get('last_tx', '')
            except:
                return ''
        return ''
    
    def save_last_tx(self, tx_hash: str):
        with open(TETHER_FILE, 'w') as f:
            json.dump({'last_tx': tx_hash}, f)
    
    async def fetch_tether_mints(self) -> List[Dict]:
        current_time = time.time()
        if self.cached_mints and (current_time - self.cache_time) < 300:
            return self.cached_mints
        
        if ETHERSCAN_API_KEY:
            mints = await self.fetch_tether_mints_etherscan()
            if mints:
                self.cached_mints = mints
                self.cache_time = current_time
                return mints
        
        mints = await self.fetch_tether_mints_blockscout()
        if mints:
            self.cached_mints = mints
            self.cache_time = current_time
        
        return mints
    
    async def fetch_tether_mints_etherscan(self) -> List[Dict]:
        async with aiohttp.ClientSession() as session:
            try:
                url = "https://api.etherscan.io/api"
                params = {
                    'module': 'account',
                    'action': 'txlist',
                    'address': TETHER_TREASURY,
                    'startblock': 0,
                    'endblock': 99999999,
                    'page': 1,
                    'offset': 100,
                    'sort': 'desc',
                    'apikey': ETHERSCAN_API_KEY
                }
                
                print(f"Fetching from Etherscan API: {TETHER_TREASURY}")
                
                async with session.get(url, params=params, timeout=aiohttp.ClientTimeout(total=15)) as resp:
                    if resp.status == 200:
                        data = await resp.json()
                        
                        if data.get('status') == '1' and data.get('result'):
                            print(f"Etherscan: Found {len(data['result'])} transactions")
                            
                            txs = []
                            for tx in data['result']:
                                from_addr = tx.get('from', '').lower()
                                to_addr = tx.get('to', '').lower()
                                
                                if from_addr == TETHER_MULTISIG.lower() and to_addr == TETHER_TREASURY.lower():
                                    txs.append(tx)
                                    if len(txs) >= 10:
                                        break
                            
                            print(f"Found {len(txs)} Tether mints from Etherscan")
                            return txs
                        else:
                            print(f"Etherscan API error: {data.get('message', 'Unknown error')}")
            except Exception as e:
                print(f"Etherscan error: {e}")
        return []
    
    async def fetch_tether_mints_blockscout(self) -> List[Dict]:
        async with aiohttp.ClientSession() as session:
            try:
                url = f"https://eth.blockscout.com/api/v2/addresses/{TETHER_TREASURY}/transactions"
                print(f"Fetching from Blockscout: {TETHER_TREASURY}")
                
                async with session.get(url, timeout=aiohttp.ClientTimeout(total=15)) as resp:
                    if resp.status == 200:
                        data = await resp.json()
                        print(f"Blockscout: Found {len(data.get('items', []))} transactions")
                        
                        txs = []
                        for tx in data.get('items', [])[:100]:
                            from_addr = tx.get('from', {}).get('hash', '').lower()
                            to_addr = tx.get('to', {}).get('hash', '').lower()
                            
                            if from_addr == TETHER_MULTISIG.lower() and to_addr == TETHER_TREASURY.lower():
                                timestamp_str = tx.get('timestamp', '')
                                try:
                                    dt = datetime.fromisoformat(timestamp_str.replace('Z', '+00:00'))
                                    timestamp = str(int(dt.timestamp()))
                                except:
                                    timestamp = str(int(time.time()))
                                
                                formatted_tx = {
                                    'hash': tx.get('hash', ''),
                                    'value': tx.get('value', '0'),
                                    'timeStamp': timestamp,
                                    'from': from_addr,
                                    'to': to_addr
                                }
                                txs.append(formatted_tx)
                                if len(txs) >= 10:
                                    break
                        
                        print(f"Found {len(txs)} Tether mints from Blockscout")
                        return txs
            except Exception as e:
                print(f"Blockscout error: {e}")
        return []
    
    def format_time_ago(self, timestamp: int) -> str:
        now = datetime.now(timezone.utc)
        tx_time = datetime.fromtimestamp(int(timestamp), timezone.utc)
        diff = now - tx_time
        
        days = diff.days
        hours = diff.seconds // 3600
        minutes = (diff.seconds % 3600) // 60
        
        if days > 0:
            return f"{days}Â§©{hours}Â∞èÊôÇÂâç"
        elif hours > 0:
            return f"{hours}Â∞èÊôÇ{minutes}ÂàÜÈêòÂâç"
        else:
            return f"{minutes}ÂàÜÈêòÂâç"

class XTracker:
    def __init__(self):
        self.accounts: Dict[str, str] = self.load_accounts()
        self.last_tweets: Dict[str, str] = self.load_last_tweets()
        self.user_ids: Dict[str, str] = self.load_user_ids()
    
    def load_accounts(self) -> Dict[str, str]:
        if os.path.exists(X_FILE):
            try:
                with open(X_FILE, 'r', encoding='utf-8') as f:
                    return json.load(f)
            except:
                return {}
        return {}
    
    def save_accounts(self):
        with open(X_FILE, 'w', encoding='utf-8') as f:
            json.dump(self.accounts, f, ensure_ascii=False, indent=2)
    
    def load_last_tweets(self) -> Dict[str, str]:
        if os.path.exists(X_LAST_FILE):
            try:
                with open(X_LAST_FILE, 'r', encoding='utf-8') as f:
                    return json.load(f)
            except:
                return {}
        return {}
    
    def save_last_tweets(self):
        with open(X_LAST_FILE, 'w', encoding='utf-8') as f:
            json.dump(self.last_tweets, f, ensure_ascii=False, indent=2)
    
    def load_user_ids(self) -> Dict[str, str]:
        if os.path.exists(X_USER_IDS):
            try:
                with open(X_USER_IDS, 'r', encoding='utf-8') as f:
                    return json.load(f)
            except:
                return {}
        return {}
    
    def save_user_ids(self):
        with open(X_USER_IDS, 'w', encoding='utf-8') as f:
            json.dump(self.user_ids, f, ensure_ascii=False, indent=2)
    
    def add_account(self, username: str, user_id: str = None) -> bool:
        username = username.lstrip('@').lower()
        if username not in self.accounts:
            self.accounts[username] = username
            if user_id:
                self.user_ids[username] = user_id
            self.save_accounts()
            self.save_user_ids()
            return True
        return False
    
    def remove_account(self, username: str) -> bool:
        username = username.lstrip('@').lower()
        if username in self.accounts:
            del self.accounts[username]
            self.save_accounts()
            if username in self.last_tweets:
                del self.last_tweets[username]
                self.save_last_tweets()
            if username in self.user_ids:
                del self.user_ids[username]
                self.save_user_ids()
            return True
        return False
    
    async def get_user_id(self, username: str) -> Optional[str]:
        username = username.lstrip('@').lower()
        
        if username in self.user_ids:
            return self.user_ids[username]
        
        if not RAPIDAPI_KEY:
            print("Error: RAPIDAPI_KEY not set")
            return None
        
        async with aiohttp.ClientSession() as session:
            try:
                url = f"https://{RAPIDAPI_HOST}/user"
                querystring = {"username": username}
                headers = {
                    "x-rapidapi-key": RAPIDAPI_KEY,
                    "x-rapidapi-host": RAPIDAPI_HOST
                }
                
                print(f"Fetching user ID for @{username}")
                
                async with session.get(url, headers=headers, params=querystring, timeout=aiohttp.ClientTimeout(total=15)) as resp:
                    if resp.status == 200:
                        data = await resp.json()
                        print(f"User API response: {data}")
                        
                        if isinstance(data, dict) and 'userId' in data:
                            user_id = str(data['userId'])
                            self.user_ids[username] = user_id
                            self.save_user_ids()
                            return user_id
                    else:
                        print(f"X API error (user): {resp.status}")
                        error_text = await resp.text()
                        print(f"Error: {error_text}")
            except Exception as e:
                print(f"Error getting user ID for {username}: {e}")
        return None
    
    async def fetch_user_tweets(self, username: str) -> List[Dict]:
        if not RAPIDAPI_KEY:
            print("Error: RAPIDAPI_KEY not set")
            return []
        
        username = username.lstrip('@').lower()
        user_id = await self.get_user_id(username)
        
        if not user_id:
            print(f"Could not get user ID for {username}")
            return []
        
        async with aiohttp.ClientSession() as session:
            try:
                url = f"https://{RAPIDAPI_HOST}/tweet-details"
                querystring = {"userId": user_id, "count": "10"}
                headers = {
                    "x-rapidapi-key": RAPIDAPI_KEY,
                    "x-rapidapi-host": RAPIDAPI_HOST
                }
                
                print(f"Fetching tweets for @{username} (ID: {user_id})")
                
                async with session.get(url, headers=headers, params=querystring, timeout=aiohttp.ClientTimeout(total=15)) as resp:
                    if resp.status == 200:
                        data = await resp.json()
                        print(f"Tweets API response type: {type(data)}")
                        
                        tweets = []
                        if isinstance(data, list):
                            tweets = data[:10]
                        elif isinstance(data, dict) and 'tweets' in data:
                            tweets = data['tweets'][:10]
                        
                        print(f"Found {len(tweets)} tweets")
                        return tweets
                    else:
                        print(f"X API error (tweets): {resp.status}")
                        error_text = await resp.text()
                        print(f"Error response: {error_text}")
            except Exception as e:
                print(f"Error fetching tweets for {username}: {e}")
        return []
    
    def format_time_ago(self, created_at: str) -> str:
        try:
            tweet_time = datetime.strptime(created_at, '%a %b %d %H:%M:%S %z %Y')
            now = datetime.now(timezone.utc)
            diff = now - tweet_time
            
            days = diff.days
            hours = diff.seconds // 3600
            minutes = (diff.seconds % 3600) // 60
            
            if days > 0:
                return f"{days}Â§©{hours}Â∞èÊôÇÂâç"
            elif hours > 0:
                return f"{hours}Â∞èÊôÇ{minutes}ÂàÜÈêòÂâç"
            else:
                return f"{minutes}ÂàÜÈêòÂâç"
        except:
            return "Êú™Áü•ÊôÇÈñì"

class MEXCTracker:
    def __init__(self):
        self.last_order_id = self.load_last_order()
    
    def load_last_order(self) -> str:
        if os.path.exists(MEXC_LAST_FILE):
            try:
                with open(MEXC_LAST_FILE, 'r') as f:
                    data = json.load(f)
                    return data.get('last_order', '')
            except:
                return ''
        return ''
    
    def save_last_order(self, order_id: str):
        with open(MEXC_LAST_FILE, 'w') as f:
            json.dump({'last_order': order_id}, f)
    
    def generate_signature(self, params: str) -> str:
        if not MEXC_SECRET_KEY:
            return ''
        return hmac.new(
            MEXC_SECRET_KEY.encode('utf-8'),
            params.encode('utf-8'),
            hashlib.sha256
        ).hexdigest()
    
    async def fetch_orders(self) -> List[Dict]:
        if not MEXC_ACCESS_KEY or not MEXC_SECRET_KEY:
            print("Error: MEXC keys not set")
            return []
        
        timestamp = int(time.time() * 1000)
        
        params = {
            'timestamp': timestamp,
            'recvWindow': 5000
        }
        
        query_string = '&'.join([f"{k}={v}" for k, v in sorted(params.items())])
        
        signature = hmac.new(
            MEXC_SECRET_KEY.encode('utf-8'),
            query_string.encode('utf-8'),
            hashlib.sha256
        ).hexdigest()
        
        params['signature'] = signature
        
        async with aiohttp.ClientSession() as session:
            try:
                url = "https://contract.mexc.com/api/v1/private/order/list/history"
                headers = {
                    "ApiKey": MEXC_ACCESS_KEY,
                    "Request-Time": str(timestamp),
                    "Content-Type": "application/json"
                }
                
                print(f"Fetching MEXC orders...")
                print(f"Query string: {query_string}")
                print(f"Signature: {signature[:20]}...")
                
                async with session.get(url, params=params, headers=headers, timeout=aiohttp.ClientTimeout(total=15)) as resp:
                    print(f"MEXC response status: {resp.status}")
                    
                    if resp.status == 200:
                        data = await resp.json()
                        print(f"MEXC response: {data}")
                        
                        if data.get('success'):
                            orders = data.get('data', [])
                            print(f"Found {len(orders)} MEXC orders")
                            return orders
                        else:
                            print(f"MEXC API error: {data.get('message', 'Unknown error')}")
                    else:
                        error_text = await resp.text()
                        print(f"MEXC HTTP error: {resp.status}")
                        print(f"Error response: {error_text}")
            except Exception as e:
                print(f"Error fetching MEXC orders: {e}")
        return []

tracker = WhaleTracker()
tether_tracker = TetherTracker()
x_tracker = XTracker()
mexc_tracker = MEXCTracker()

def get_keyboard(address: str = None) -> InlineKeyboardMarkup:
    keyboard = []
    if address:
        keyboard.append([InlineKeyboardButton("üîÑ Á´ãÂç≥Êõ¥Êñ∞", callback_data=f"refresh:{address}")])
        keyboard.append([InlineKeyboardButton("üìã Ë§áË£ΩÂú∞ÂùÄ", callback_data=f"copy:{address}")])
    else:
        keyboard.append([InlineKeyboardButton("üîÑ Á´ãÂç≥Êõ¥Êñ∞", callback_data="refresh_all")])
    return InlineKeyboardMarkup(keyboard)

def get_whale_list_keyboard(action: str) -> InlineKeyboardMarkup:
    keyboard = []
    for address, name in tracker.whales.items():
        keyboard.append([InlineKeyboardButton(
            f"üêã {name}", 
            callback_data=f"{action}:{address}"
        )])
    keyboard.append([InlineKeyboardButton("‚ùå ÂèñÊ∂à", callback_data="cancel")])
    return InlineKeyboardMarkup(keyboard)

def get_batch_remove_keyboard() -> InlineKeyboardMarkup:
    keyboard = []
    for address, name in tracker.whales.items():
        keyboard.append([InlineKeyboardButton(
            f"‚òëÔ∏è {name}", 
            callback_data=f"toggle_remove:{address}"
        )])
    keyboard.append([
        InlineKeyboardButton("‚úÖ Á¢∫Ë™çÁßªÈô§", callback_data="confirm_batch_remove"),
        InlineKeyboardButton("‚ùå ÂèñÊ∂à", callback_data="cancel")
    ])
    return InlineKeyboardMarkup(keyboard)

async def setup_commands(application: Application):
    commands = [
        BotCommand("start", "ü§ñ ÂïüÂãïÊ©üÂô®‰∫∫"),
        
        BotCommand("add", "üêã Êñ∞Â¢ûÂ∑®ÈØ®"),
        BotCommand("batchadd", "üêã ÊâπÈáèÊñ∞Â¢ûÂ∑®ÈØ®"),
        BotCommand("remove", "üêã ÁßªÈô§Â∑®ÈØ®"),
        BotCommand("batchremove", "üêã ÊâπÈáèÁßªÈô§Â∑®ÈØ®"),
        BotCommand("list", "üêã Êü•ÁúãËøΩËπ§ÂàóË°®"),
        BotCommand("whalecheck", "üêã Êü•ÁúãÁâπÂÆöÂ∑®ÈØ®"),
        BotCommand("allwhale", "üêã Êü•ÁúãÊâÄÊúâÂ∑®ÈØ®ÊåÅÂÄâ"),
        
        BotCommand("checktether", "üíµ Êü•ÁúãËøë10Á≠ÜUSDTÈëÑÈÄ†"),
        
        BotCommand("addx", "üê¶ Êñ∞Â¢ûXÂ∏≥ËôüËøΩËπ§"),
        BotCommand("removex", "üê¶ ÁßªÈô§XÂ∏≥ËôüËøΩËπ§"),
        BotCommand("listx", "üê¶ Êü•ÁúãËøΩËπ§ÁöÑXÂ∏≥Ëôü"),
        BotCommand("testx", "üê¶ Ê∏¨Ë©¶XÂ∏≥ËôüÊúÄÊñ∞ÁôºÊñá"),
        
        BotCommand("test", "üîß Ê∏¨Ë©¶APIÈÄ£Êé•"),
    ]
    await application.bot.set_my_commands(commands)

async def start(update: Update, context: ContextTypes.DEFAULT_TYPE):
    chat_id = update.effective_chat.id
    tracker.subscribed_chats.add(chat_id)
    
    await update.message.reply_text(
        "ü§ñ <b>Hyperliquid Bot</b>\n\n"
        "üêã <b>Â∑®ÈØ®ËøΩËπ§:</b>\n"
        "/add - Êñ∞Â¢ûÂ∑®ÈØ®\n"
        "/batchadd - ÊâπÈáèÊñ∞Â¢ûÂ∑®ÈØ®\n"
        "/remove - ÁßªÈô§Â∑®ÈØ®\n"
        "/batchremove - ÊâπÈáèÁßªÈô§Â∑®ÈØ®\n"
        "/list - Êü•ÁúãËøΩËπ§ÂàóË°®\n"
        "/whalecheck - Êü•ÁúãÁâπÂÆöÂ∑®ÈØ®\n"
        "/allwhale - Êü•ÁúãÊâÄÊúâÂ∑®ÈØ®ÊåÅÂÄâ\n\n"
        "üíµ <b>Tether ÈëÑÈÄ†ËøΩËπ§:</b>\n"
        "/checktether - Êü•ÁúãËøë10Á≠ÜUSDTÈëÑÈÄ†\n\n"
        "üê¶ <b>X ËøΩËπ§:</b>\n"
        "/addx - Êñ∞Â¢ûXÂ∏≥ËôüËøΩËπ§\n"
        "/removex - ÁßªÈô§XÂ∏≥ËôüËøΩËπ§\n"
        "/listx - Êü•ÁúãËøΩËπ§ÁöÑXÂ∏≥Ëôü\n"
        "/testx - Ê∏¨Ë©¶XÂ∏≥ËôüÊúÄÊñ∞ÁôºÊñá\n\n"
        "üìä <b>MEXC ËøΩËπ§:</b>\n"
        "/checkmexc - Êü•ÁúãMEXCÂêàÁ¥Ñ‰∫§Êòì\n\n"
        "üîß <b>Á≥ªÁµ±ÂäüËÉΩ:</b>\n"
        "/test - Ê∏¨Ë©¶APIÈÄ£Êé•",
        parse_mode='HTML'
    )

async def test_api(update: Update, context: ContextTypes.DEFAULT_TYPE):
    await update.message.reply_text("üîç Ê≠£Âú®Ê∏¨Ë©¶APIÈÄ£Êé•...")
    
    results = []
    results.append(f"üìù TELEGRAM_TOKEN: {'‚úÖ Â∑≤Ë®≠ÁΩÆ' if TELEGRAM_TOKEN else '‚ùå Êú™Ë®≠ÁΩÆ'}")
    results.append(f"üåê HYPERLIQUID_API: {'‚úÖ Â∑≤Ë®≠ÁΩÆ' if HYPERLIQUID_API else '‚ùå Êú™Ë®≠ÁΩÆ'}")
    results.append(f"üîë RAPIDAPI_KEY: {'‚úÖ Â∑≤Ë®≠ÁΩÆ' if RAPIDAPI_KEY else '‚ùå Êú™Ë®≠ÁΩÆ'}")
    results.append(f"üîë ETHERSCAN_API_KEY: {'‚úÖ Â∑≤Ë®≠ÁΩÆ' if ETHERSCAN_API_KEY else '‚ùå Êú™Ë®≠ÁΩÆ'}")
    results.append(f"üìä MEXC_ACCESS_KEY: {'‚úÖ Â∑≤Ë®≠ÁΩÆ' if MEXC_ACCESS_KEY else '‚ùå Êú™Ë®≠ÁΩÆ'}")
    results.append(f"üìä MEXC_SECRET_KEY: {'‚úÖ Â∑≤Ë®≠ÁΩÆ' if MEXC_SECRET_KEY else '‚ùå Êú™Ë®≠ÁΩÆ'}")
    
    hyperliquid_test = "‚ùå ÁÑ°Ê≥ïÈÄ£Êé•"
    try:
        async with aiohttp.ClientSession() as session:
            async with session.post(
                f'{HYPERLIQUID_API}/info',
                json={'type': 'meta'},
                timeout=aiohttp.ClientTimeout(total=10)
            ) as resp:
                if resp.status == 200:
                    hyperliquid_test = "‚úÖ ÈÄ£Êé•ÊàêÂäü"
    except Exception as e:
        hyperliquid_test = f"‚ùå ÈÄ£Êé•Â§±Êïó: {str(e)[:30]}"
    
    results.append(f"üîó Hyperliquid API: {hyperliquid_test}")
    
    etherscan_test = "‚ùå ÁÑ°Ê≥ïÈÄ£Êé•"
    if ETHERSCAN_API_KEY:
        try:
            async with aiohttp.ClientSession() as session:
                url = "https://api.etherscan.io/api"
                params = {
                    'module': 'account',
                    'action': 'balance',
                    'address': TETHER_TREASURY,
                    'tag': 'latest',
                    'apikey': ETHERSCAN_API_KEY
                }
                async with session.get(url, params=params, timeout=aiohttp.ClientTimeout(total=10)) as resp:
                    if resp.status == 200:
                        data = await resp.json()
                        if data.get('status') == '1':
                            etherscan_test = "‚úÖ ÈÄ£Êé•ÊàêÂäü"
                        elif data.get('message') == 'NOTOK':
                            etherscan_test = f"‚ùå API Key ÁÑ°ÊïàÊàñÂ∑≤ÈÅéÊúü"
                        else:
                            etherscan_test = f"‚ùå {data.get('result', 'Error')}"
                    else:
                        etherscan_test = f"‚ùå HTTP {resp.status}"
        except Exception as e:
            etherscan_test = f"‚ùå {str(e)[:20]}"
    else:
        etherscan_test = "‚ùå Êú™Ë®≠ÁΩÆ API Key"
    results.append(f"üîó Etherscan API: {etherscan_test}")
    
    rapidapi_test = "‚ùå ÁÑ°Ê≥ïÈÄ£Êé•"
    if RAPIDAPI_KEY and RAPIDAPI_HOST:
        try:
            async with aiohttp.ClientSession() as session:
                url = f"https://{RAPIDAPI_HOST}/user"
                headers = {
                    "x-rapidapi-key": RAPIDAPI_KEY,
                    "x-rapidapi-host": RAPIDAPI_HOST
                }
                querystring = {"username": "elonmusk"}
                async with session.get(url, headers=headers, params=querystring, timeout=aiohttp.ClientTimeout(total=10)) as resp:
                    if resp.status == 200:
                        rapidapi_test = "‚úÖ ÈÄ£Êé•ÊàêÂäü"
                    elif resp.status == 404:
                        rapidapi_test = "‚ùå APIÁ´ØÈªû‰∏çÂ≠òÂú®"
                    elif resp.status == 403:
                        rapidapi_test = "‚ùå API Key ÁÑ°ÊïàÊàñÁÑ°Ê¨äÈôê"
                    elif resp.status == 429:
                        rapidapi_test = "‚ùå Ë´ãÊ±ÇÊ¨°Êï∏Ë∂ÖÈôê"
                    else:
                        rapidapi_test = f"‚ùå HTTP {resp.status}"
        except Exception as e:
            rapidapi_test = f"‚ùå {str(e)[:20]}"
    else:
        rapidapi_test = "‚ùå Êú™Ë®≠ÁΩÆ API Key Êàñ Host"
    results.append(f"üîó X API: {rapidapi_test}")
    
    mexc_test = "‚ùå ÁÑ°Ê≥ïÈÄ£Êé•"
    if MEXC_ACCESS_KEY and MEXC_SECRET_KEY:
        try:
            timestamp = int(time.time() * 1000)
            params = {
                'timestamp': timestamp,
                'recvWindow': 5000
            }
            query_string = '&'.join([f"{k}={v}" for k, v in sorted(params.items())])
            signature = hmac.new(
                MEXC_SECRET_KEY.encode('utf-8'),
                query_string.encode('utf-8'),
                hashlib.sha256
            ).hexdigest()
            params['signature'] = signature
            
            async with aiohttp.ClientSession() as session:
                url = "https://contract.mexc.com/api/v1/private/account/assets"
                headers = {
                    "ApiKey": MEXC_ACCESS_KEY,
                    "Request-Time": str(timestamp),
                    "Content-Type": "application/json"
                }
                async with session.get(url, params=params, headers=headers, timeout=aiohttp.ClientTimeout(total=10)) as resp:
                    if resp.status == 200:
                        data = await resp.json()
                        if data.get('success'):
                            mexc_test = "‚úÖ ÈÄ£Êé•ÊàêÂäü"
                        else:
                            mexc_test = f"‚ùå {data.get('message', 'Error')[:30]}"
                    else:
                        error_text = await resp.text()
                        mexc_test = f"‚ùå HTTP {resp.status}: {error_text[:30]}"
        except Exception as e:
            mexc_test = f"‚ùå {str(e)[:30]}"
    else:
        mexc_test = "‚ùå Êú™Ë®≠ÁΩÆ API Keys"
    results.append(f"üîó MEXC API: {mexc_test}")
    
    result_text = "üìä <b>API Ê∏¨Ë©¶ÁµêÊûú:</b>\n\n" + "\n".join(results)
    
    issues = [r for r in results if '‚ùå' in r]
    if issues:
        result_text += "\n\n‚ö†Ô∏è <b>ÁôºÁèæÂïèÈ°å:</b>\n" + "\n".join(issues)
    else:
        result_text += "\n\n‚úÖ ÊâÄÊúâAPIÈÅã‰ΩúÊ≠£Â∏∏ÔºÅ"
    
    await update.message.reply_text(result_text, parse_mode='HTML')

async def check_tether(update: Update, context: ContextTypes.DEFAULT_TYPE):
    await update.message.reply_text("üîç Êü•Ë©¢ USDT ÈëÑÈÄ†Ë®òÈåÑ...")
    
    mints = await tether_tracker.fetch_tether_mints()
    
    if not mints:
        await update.message.reply_text("‚ùå ÁÑ°Ê≥ïÁç≤ÂèñÊï∏Êìö\nË´ãÁ¢∫Ë™ç .env ‰∏≠Â∑≤Ë®≠ÁΩÆ ETHERSCAN_API_KEY")
        return
    
    text = "üíµ <b>Ëøë10Á≠Ü USDT ÈëÑÈÄ†:</b>\n\n"
    for i, tx in enumerate(mints[:10], 1):
        value_eth = int(tx['value']) / 10**18
        time_ago = tether_tracker.format_time_ago(tx['timeStamp'])
        text += f"{i}. üí∞ {value_eth:,.0f} USDT\n   ‚è∞ {time_ago}\n\n"
    
    await update.message.reply_text(text, parse_mode='HTML')

async def check_mexc(update: Update, context: ContextTypes.DEFAULT_TYPE):
    await update.message.reply_text("üîç Êü•Ë©¢ÊÇ®ÁöÑ MEXC ÂêàÁ¥Ñ‰∫§Êòì...")
    
    if not MEXC_ACCESS_KEY or not MEXC_SECRET_KEY:
        await update.message.reply_text(
            "‚ùå MEXC API Êú™ÈÖçÁΩÆ\n\n"
            "Ë´ãÂú® .env Ê∑ªÂä†:\n"
            "MEXC_ACCESS_KEY=‰Ω†ÁöÑkey\n"
            "MEXC_SECRET_KEY=‰Ω†ÁöÑsecret"
        )
        return
    
    orders = await mexc_tracker.fetch_orders()
    
    if not orders:
        await update.message.reply_text(
            "‚ùå ÁÑ°Ê≥ïÁç≤Âèñ MEXC Êï∏Êìö\n\n"
            "ÂèØËÉΩÂéüÂõ†:\n"
            "1. API Keys ÈåØË™§\n"
            "2. API Ê¨äÈôê‰∏çË∂≥\n"
            "3. IP Êú™Âä†ÂÖ•ÁôΩÂêçÂñÆ\n"
            "4. ËøëÊúüÊ≤íÊúâ‰∫§ÊòìË®òÈåÑ\n\n"
            "Ë´ãÊ™¢Êü• MEXC Â∏≥Êà∂ÁöÑ API Ë®≠ÁΩÆ"
        )
        return
    
    text = "üìä <b>ÊÇ®ÁöÑËøëÊúüMEXCÂêàÁ¥Ñ‰∫§Êòì:</b>\n\n"
    for i, order in enumerate(orders[:10], 1):
        symbol = order.get('symbol', 'N/A')
        side = "ÂÅöÂ§ö" if order.get('side') == 1 else "ÂÅöÁ©∫"
        price = order.get('price', 0)
        vol = order.get('vol', 0)
        text += f"{i}. {symbol} {side}\n   ÂÉπÊ†º: ${price} Êï∏Èáè: {vol}\n\n"
    
    await update.message.reply_text(text, parse_mode='HTML')

async def add_start(update: Update, context: ContextTypes.DEFAULT_TYPE):
    await update.message.reply_text("üìù Ë´ãËº∏ÂÖ•Â∑®ÈØ®Âú∞ÂùÄ:")
    return ADD_ADDRESS

async def add_address(update: Update, context: ContextTypes.DEFAULT_TYPE):
    context.user_data['whale_address'] = update.message.text.strip()
    await update.message.reply_text("üìù Ë´ãËº∏ÂÖ•ÂÇôË®ª:")
    return ADD_NAME

async def add_name(update: Update, context: ContextTypes.DEFAULT_TYPE):
    address = context.user_data.get('whale_address')
    name = update.message.text.strip()
    
    if tracker.add_whale(address, name):
        await update.message.reply_text(f"‚úÖ Â∑≤Êñ∞Â¢û: {name}")
    else:
        await update.message.reply_text("‚ö†Ô∏è Â∑≤Â≠òÂú®")
    
    return ConversationHandler.END

async def add_cancel(update: Update, context: ContextTypes.DEFAULT_TYPE):
    await update.message.reply_text("‚ùå Â∑≤ÂèñÊ∂à")
    return ConversationHandler.END

async def remove_whale(update: Update, context: ContextTypes.DEFAULT_TYPE):
    if not tracker.whales:
        await update.message.reply_text("üì≠ ÁÑ°Â∑®ÈØ®")
        return
    
    keyboard = get_whale_list_keyboard("remove")
    await update.message.reply_text("ÈÅ∏ÊìáÁßªÈô§:", reply_markup=keyboard)

async def list_whales(update: Update, context: ContextTypes.DEFAULT_TYPE):
    if not tracker.whales:
        await update.message.reply_text("üì≠ ÁÑ°Â∑®ÈØ®")
        return
    
    text = "üêã <b>Â∑®ÈØ®ÂàóË°®:</b>\n\n"
    for i, (addr, name) in enumerate(tracker.whales.items(), 1):
        text += f"{i}. {name}\n{addr}\n\n"
    
    await update.message.reply_text(text, parse_mode='HTML')

async def show_all_positions(update: Update, context: ContextTypes.DEFAULT_TYPE):
    if not tracker.whales:
        await update.message.reply_text("üì≠ ÁÑ°Â∑®ÈØ®")
        return
    
    taipei_time = datetime.now(timezone(timedelta(hours=8)))
    
    for address, name in tracker.whales.items():
        positions = await tracker.fetch_positions(address)
        if not positions:
            continue
        
        text = f"üêã <b>{name}</b>\nüïê {taipei_time.strftime('%m-%d %H:%M:%S')} (Âè∞Âåó)"
        for pos in positions:
            text += tracker.format_position(pos)
        
        await update.message.reply_text(text, parse_mode='HTML', reply_markup=get_keyboard(address))
        await asyncio.sleep(1)

async def add_x_start(update: Update, context: ContextTypes.DEFAULT_TYPE):
    await update.message.reply_text("üìù Ëº∏ÂÖ•XÂ∏≥Ëôü (‰∏çÂê´@):")
    return ADD_X

async def add_x_account(update: Update, context: ContextTypes.DEFAULT_TYPE):
    username = update.message.text.strip().lstrip('@')
    await update.message.reply_text(f"üîç È©óË≠â @{username}...")
    
    user_id = await x_tracker.get_user_id(username)
    if not user_id:
        await update.message.reply_text(f"‚ùå Êâæ‰∏çÂà∞ @{username}\nË´ãÁ¢∫Ë™ç .env ‰∏≠ÁöÑ RAPIDAPI_KEY Ë®≠ÁΩÆÊ≠£Á¢∫")
        return ConversationHandler.END
    
    if x_tracker.add_account(username, user_id):
        await update.message.reply_text(f"‚úÖ Â∑≤Êñ∞Â¢û @{username}")
    else:
        await update.message.reply_text(f"‚ö†Ô∏è Â∑≤Â≠òÂú®")
    
    return ConversationHandler.END

async def add_x_cancel(update: Update, context: ContextTypes.DEFAULT_TYPE):
    await update.message.reply_text("‚ùå Â∑≤ÂèñÊ∂à")
    return ConversationHandler.END

async def list_x(update: Update, context: ContextTypes.DEFAULT_TYPE):
    if not x_tracker.accounts:
        await update.message.reply_text("üì≠ ÁÑ°XÂ∏≥Ëôü")
        return
    
    text = "üê¶ <b>XÂ∏≥ËôüÂàóË°®:</b>\n\n"
    for i, username in enumerate(x_tracker.accounts.keys(), 1):
        text += f"{i}. @{username}\n"
    
    await update.message.reply_text(text, parse_mode='HTML')

async def remove_x(update: Update, context: ContextTypes.DEFAULT_TYPE):
    if not x_tracker.accounts:
        await update.message.reply_text("üì≠ ÁõÆÂâçÊ≤íÊúâËøΩËπ§‰ªª‰Ωï X Â∏≥Ëôü")
        return
    
    keyboard = []
    for username in x_tracker.accounts.keys():
        keyboard.append([InlineKeyboardButton(
            f"üê¶ @{username}",
            callback_data=f"remove_x:{username}"
        )])
    keyboard.append([InlineKeyboardButton("‚ùå ÂèñÊ∂à", callback_data="cancel")])
    
    await update.message.reply_text(
        "Ë´ãÈÅ∏ÊìáË¶ÅÁßªÈô§ÁöÑ X Â∏≥Ëôü:",
        reply_markup=InlineKeyboardMarkup(keyboard)
    )

async def test_x(update: Update, context: ContextTypes.DEFAULT_TYPE):
    if not x_tracker.accounts:
        await update.message.reply_text("üì≠ ÁõÆÂâçÊ≤íÊúâËøΩËπ§‰ªª‰Ωï X Â∏≥Ëôü\nË´ãÂÖà‰ΩøÁî® /addx Êñ∞Â¢ûÂ∏≥Ëôü")
        return
    
    keyboard = []
    for username in x_tracker.accounts.keys():
        keyboard.append([InlineKeyboardButton(
            f"üê¶ @{username}",
            callback_data=f"test_x:{username}"
        )])
    keyboard.append([InlineKeyboardButton("‚ùå ÂèñÊ∂à", callback_data="cancel")])
    
    await update.message.reply_text(
        "Ë´ãÈÅ∏ÊìáË¶ÅÊ∏¨Ë©¶ÁöÑ X Â∏≥Ëôü:",
        reply_markup=InlineKeyboardMarkup(keyboard)
    )

async def whale_check(update: Update, context: ContextTypes.DEFAULT_TYPE):
    if not tracker.whales:
        await update.message.reply_text("üì≠ ÁõÆÂâçÊ≤íÊúâËøΩËπ§‰ªª‰ΩïÂ∑®ÈØ®")
        return
    
    keyboard = get_whale_list_keyboard("check")
    await update.message.reply_text("Ë´ãÈÅ∏ÊìáË¶ÅÊü•ÁúãÁöÑÂ∑®ÈØ®:", reply_markup=keyboard)

async def batch_add_start(update: Update, context: ContextTypes.DEFAULT_TYPE):
    await update.message.reply_text(
        "üìù Ë´ãËº∏ÂÖ•Â∑®ÈØ®Ë≥áÊñô,ÊØèË°å‰∏ÄÂÄã,Ê†ºÂºè:\n"
        "Âú∞ÂùÄ ÂÇôË®ªÂêçÁ®±\n\n"
        "ÁØÑ‰æã:\n"
        "0x123...abc Â∑®ÈØ®A\n"
        "0x456...def Â∑®ÈØ®B",
        parse_mode='HTML'
    )
    return BATCH_ADD_DATA

async def batch_add_data(update: Update, context: ContextTypes.DEFAULT_TYPE):
    lines = update.message.text.strip().split('\n')
    added = 0
    
    for line in lines:
        parts = line.strip().split(None, 1)
        if len(parts) >= 1:
            address = parts[0]
            name = parts[1] if len(parts) > 1 else ''
            if tracker.add_whale(address, name):
                added += 1
    
    await update.message.reply_text(f"‚úÖ ÊàêÂäüÊñ∞Â¢û {added}/{len(lines)} ÂÄãÂ∑®ÈØ®")
    return ConversationHandler.END

async def batch_add_cancel(update: Update, context: ContextTypes.DEFAULT_TYPE):
    await update.message.reply_text("‚ùå Â∑≤ÂèñÊ∂àÊâπÈáèÊñ∞Â¢û")
    return ConversationHandler.END

async def batch_remove(update: Update, context: ContextTypes.DEFAULT_TYPE):
    if not tracker.whales:
        await update.message.reply_text("üì≠ ÁõÆÂâçÊ≤íÊúâËøΩËπ§‰ªª‰ΩïÂ∑®ÈØ®")
        return
    
    context.user_data['remove_list'] = []
    keyboard = get_batch_remove_keyboard()
    await update.message.reply_text("Ë´ãÈÅ∏ÊìáË¶ÅÁßªÈô§ÁöÑÂ∑®ÈØ® (ÂèØÂ§öÈÅ∏):", reply_markup=keyboard)

async def button_callback(update: Update, context: ContextTypes.DEFAULT_TYPE):
    query = update.callback_query
    await query.answer()
    
    data = query.data
    
    if data == "cancel":
        await query.edit_message_text("‚ùå Â∑≤ÂèñÊ∂à")
        return
    
    if data.startswith("copy:"):
        address = data.split(":", 1)[1]
        await query.answer(f"Âú∞ÂùÄ: {address}", show_alert=True)
        return
    
    if data.startswith("refresh:"):
        address = data.split(":", 1)[1]
        await query.answer("üîÑ Êõ¥Êñ∞‰∏≠...")
        
        name = tracker.whales.get(address, address[:8])
        positions = await tracker.fetch_positions(address)
        
        if not positions:
            await query.message.reply_text(f"üì≠ {name} ÁÑ°ÊåÅÂÄâ")
            return
        
        taipei_time = datetime.now(timezone(timedelta(hours=8)))
        text = f"üêã <b>{name}</b>\nüïê {taipei_time.strftime('%m-%d %H:%M:%S')} (Âè∞Âåó)"
        
        for pos in positions:
            text += tracker.format_position(pos)
        
        await query.message.reply_text(text, parse_mode='HTML', reply_markup=get_keyboard(address))
        return
    
    if data.startswith("remove:"):
        address = data.split(":", 1)[1]
        name = tracker.whales.get(address, address[:8])
        
        if tracker.remove_whale(address):
            await query.edit_message_text(f"‚úÖ Â∑≤ÁßªÈô§: {name}")
        else:
            await query.edit_message_text("‚ö†Ô∏è Â§±Êïó")
        return
    
    if data.startswith("check:"):
        address = data.split(":", 1)[1]
        positions = await tracker.fetch_positions(address)
        
        if not positions:
            await query.edit_message_text(f"üì≠ Ë©≤Â∑®ÈØ®ÁõÆÂâçÊ≤íÊúâÊåÅÂÄâ")
            return
        
        name = tracker.whales.get(address, address[:8])
        taipei_time = datetime.now(timezone(timedelta(hours=8)))
        
        text = f"üêã <b>{name}</b>\nüïê {taipei_time.strftime('%m-%d %H:%M:%S')} (Âè∞Âåó)"
        
        for pos in positions:
            text += tracker.format_position(pos)
        
        await query.message.reply_text(text, parse_mode='HTML', reply_markup=get_keyboard(address))
        await query.edit_message_text("‚úÖ Â∑≤È°ØÁ§∫Â∑®ÈØ®ÊåÅÂÄâ")
        return
    
    if data.startswith("remove_x:"):
        username = data.split(":", 1)[1]
        
        if x_tracker.remove_account(username):
            await query.edit_message_text(f"‚úÖ Â∑≤ÁßªÈô§ X Â∏≥Ëôü: @{username}")
        else:
            await query.edit_message_text("‚ö†Ô∏è ÁßªÈô§Â§±Êïó")
        return
    
    if data.startswith("test_x:"):
        username = data.split(":", 1)[1]
        await query.answer("üîç Ê≠£Âú®Áç≤ÂèñÊúÄÊñ∞ÁôºÊñá...")
        
        tweets = await x_tracker.fetch_user_tweets(username)
        
        if not tweets:
            await query.message.reply_text(f"‚ùå ÁÑ°Ê≥ïÁç≤Âèñ @{username} ÁöÑÁôºÊñá")
            await query.edit_message_text("‚ùå Ê∏¨Ë©¶Â§±Êïó")
            return
        
        latest_tweet = tweets[0]
        tweet_text = latest_tweet.get('text') or latest_tweet.get('full_text') or 'ÁÑ°ÂÖßÂÆπ'
        created_at = latest_tweet.get('created_at', '')
        tweet_id = latest_tweet.get('id_str') or latest_tweet.get('id') or ''
        time_ago = x_tracker.format_time_ago(created_at) if created_at else "Êú™Áü•ÊôÇÈñì"
        
        text = f"üê¶ <b>X Ê∏¨Ë©¶ÁµêÊûú</b>\n\n"
        text += f"üë§ <b>@{username}</b> ÁöÑÊúÄÊñ∞ÁôºÊñá:\n\n"
        text += f"üìù {tweet_text}\n\n"
        text += f"‚è∞ ÁôºÂ∏ÉÊôÇÈñì: {time_ago}\n"
        if tweet_id:
            text += f"üîó https://twitter.com/{username}/status/{tweet_id}"
        
        await query.message.reply_text(text, parse_mode='HTML')
        await query.edit_message_text("‚úÖ Ê∏¨Ë©¶ÂÆåÊàê")
        return
    
    if data.startswith("toggle_remove:"):
        address = data.split(":", 1)[1]
        remove_list = context.user_data.get('remove_list', [])
        
        if address in remove_list:
            remove_list.remove(address)
        else:
            remove_list.append(address)
        
        context.user_data['remove_list'] = remove_list
        
        keyboard = []
        for addr, name in tracker.whales.items():
            emoji = "‚úÖ" if addr in remove_list else "‚òëÔ∏è"
            keyboard.append([InlineKeyboardButton(
                f"{emoji} {name}", 
                callback_data=f"toggle_remove:{addr}"
            )])
        keyboard.append([
            InlineKeyboardButton("‚úÖ Á¢∫Ë™çÁßªÈô§", callback_data="confirm_batch_remove"),
            InlineKeyboardButton("‚ùå ÂèñÊ∂à", callback_data="cancel")
        ])
        
        await query.edit_message_reply_markup(reply_markup=InlineKeyboardMarkup(keyboard))
        return
    
    if data == "confirm_batch_remove":
        remove_list = context.user_data.get('remove_list', [])
        
        if not remove_list:
            await query.edit_message_text("‚ö†Ô∏è Êú™ÈÅ∏Êìá‰ªª‰ΩïÂ∑®ÈØ®")
            return
        
        removed = 0
        for address in remove_list:
            if tracker.remove_whale(address):
                removed += 1
        
        context.user_data['remove_list'] = []
        await query.edit_message_text(f"‚úÖ ÊàêÂäüÁßªÈô§ {removed} ÂÄãÂ∑®ÈØ®")
        return

async def auto_update(context: ContextTypes.DEFAULT_TYPE):
    if not tracker.whales or not tracker.subscribed_chats:
        return
    
    taipei_time = datetime.now(timezone(timedelta(hours=8)))
    is_30min_mark = (taipei_time.minute == 0 or taipei_time.minute == 30) and taipei_time.second < 60
    
    for address, name in tracker.whales.items():
        positions = await tracker.fetch_positions(address)
        
        if not positions:
            continue
        
        changed, margin_diff = tracker.positions_changed(address, positions)
        
        should_notify = False
        notification_type = ""
        
        if changed:
            should_notify = True
            notification_type = "üîî ÊåÅÂÄâËÆäÂãïÈÄöÁü•"
            
            new_margins = {}
            for p in positions:
                coin = p['position']['coin']
                margin = float(p['position'].get('marginUsed', '0'))
                new_margins[coin] = margin
            tracker.last_positions[address] = new_margins
            
        elif is_30min_mark:
            should_notify = True
            notification_type = "üîî Âõ∫ÂÆöÈÄöÁü•"
            
            new_margins = {}
            for p in positions:
                coin = p['position']['coin']
                margin = float(p['position'].get('marginUsed', '0'))
                new_margins[coin] = margin
            tracker.last_positions[address] = new_margins
        
        if should_notify:
            text = f"üêã <b>{name}</b>\n{notification_type}\nüïê {taipei_time.strftime('%m-%d %H:%M:%S')} (Âè∞Âåó)"
            
            for pos in positions:
                text += tracker.format_position(pos)
            
            for chat_id in tracker.subscribed_chats:
                try:
                    await context.bot.send_message(
                        chat_id=chat_id,
                        text=text,
                        parse_mode='HTML',
                        reply_markup=get_keyboard(address)
                    )
                except Exception as e:
                    print(f"Error sending message: {e}")
            
            await asyncio.sleep(1)

async def tether_update(context: ContextTypes.DEFAULT_TYPE):
    if not tracker.subscribed_chats:
        return
    
    mints = await tether_tracker.fetch_tether_mints()
    
    if not mints:
        return
    
    latest_tx = mints[0]['hash']
    
    if latest_tx != tether_tracker.last_tx_hash and tether_tracker.last_tx_hash != '':
        value_eth = int(mints[0]['value']) / 10**18
        time_ago = tether_tracker.format_time_ago(mints[0]['timeStamp'])
        
        text = f"üíµ <b>Tether ÈëÑÈÄ†ÈÄöÁü•</b>\n\n"
        text += f"üí∞ Êï∏Èáè: {value_eth:,.0f} USDT\n"
        text += f"‚è∞ {time_ago}\n"
        text += f"üîó {mints[0]['hash'][:16]}..."
        
        for chat_id in tracker.subscribed_chats:
            try:
                await context.bot.send_message(chat_id=chat_id, text=text, parse_mode='HTML')
            except Exception as e:
                print(f"Error sending Tether notification: {e}")
    
    tether_tracker.last_tx_hash = latest_tx
    tether_tracker.save_last_tx(latest_tx)

async def x_update(context: ContextTypes.DEFAULT_TYPE):
    if not x_tracker.accounts or not tracker.subscribed_chats:
        return
    
    for username in x_tracker.accounts.keys():
        tweets = await x_tracker.fetch_user_tweets(username)
        
        if not tweets:
            continue
        
        latest_tweet = tweets[0]
        tweet_id = latest_tweet.get('id_str') or latest_tweet.get('id') or ''
        tweet_id = str(tweet_id)
        
        if tweet_id and tweet_id != x_tracker.last_tweets.get(username, ''):
            x_tracker.last_tweets[username] = tweet_id
            x_tracker.save_last_tweets()
            
            tweet_text = latest_tweet.get('text') or latest_tweet.get('full_text') or 'ÁÑ°ÂÖßÂÆπ'
            created_at = latest_tweet.get('created_at', '')
            time_ago = x_tracker.format_time_ago(created_at) if created_at else "Êú™Áü•"
            
            text = f"üê¶ <b>X ÁôºÊñáÈÄöÁü•</b>\n\n"
            text += f"üë§ @{username}\n\n"
            text += f"üìù {tweet_text}\n\n"
            text += f"‚è∞ {time_ago}\n"
            text += f"üîó https://twitter.com/{username}/status/{tweet_id}"
            
            for chat_id in tracker.subscribed_chats:
                try:
                    await context.bot.send_message(chat_id=chat_id, text=text, parse_mode='HTML')
                except Exception as e:
                    print(f"Error sending X notification: {e}")
            
            await asyncio.sleep(2)

async def mexc_update(context: ContextTypes.DEFAULT_TYPE):
    if not tracker.subscribed_chats:
        return
    
    orders = await mexc_tracker.fetch_orders()
    
    if not orders:
        return
    
    latest_order = orders[0]
    order_id = str(latest_order.get('orderId', ''))
    
    if order_id and order_id != mexc_tracker.last_order_id and mexc_tracker.last_order_id != '':
        mexc_tracker.last_order_id = order_id
        mexc_tracker.save_last_order(order_id)
        
        symbol = latest_order.get('symbol', 'N/A')
        side = "ÂÅöÂ§ö" if latest_order.get('side') == 1 else "ÂÅöÁ©∫"
        price = latest_order.get('price', 0)
        vol = latest_order.get('vol', 0)
        
        text = f"üìä <b>ÊÇ®ÁöÑ MEXC ‰∫§ÊòìÈÄöÁü•</b>\n\n"
        text += f"ü™ô {symbol}\n"
        text += f"üìä {side}\n"
        text += f"üíµ ÂÉπÊ†º: ${price}\n"
        text += f"üì¶ Êï∏Èáè: {vol}"
        
        for chat_id in tracker.subscribed_chats:
            try:
                await context.bot.send_message(chat_id=chat_id, text=text, parse_mode='HTML')
            except Exception as e:
                print(f"Error sending MEXC notification: {e}")
    
    if mexc_tracker.last_order_id == '':
        mexc_tracker.last_order_id = order_id
        mexc_tracker.save_last_order(order_id)

async def error_handler(update: Update, context: ContextTypes.DEFAULT_TYPE):
    """ËôïÁêÜÊâÄÊúâÈåØË™§"""
    print(f"Update {update} caused error {context.error}")
    
    try:
        if update and update.effective_message:
            await update.effective_message.reply_text(
                "‚ùå ÁôºÁîüÈåØË™§,Ë´ãÁ®çÂæåÂÜçË©¶ÊàñËÅØÁπ´ÁÆ°ÁêÜÂì°"
            )
    except Exception as e:
        print(f"Error sending error message: {e}")

# ==================== HTTP ÂÅ•Â∫∑Ê™¢Êü•‰º∫ÊúçÂô® ====================
async def health_check(request):
    """ÂÅ•Â∫∑Ê™¢Êü•Á´ØÈªû - ‰æõ Render Ê™¢Ê∏¨Áî®"""
    return web.Response(text="‚úÖ Telegram Bot is running!")

async def start_health_server():
    """ÂïüÂãï HTTP ‰º∫ÊúçÂô®‰æõ Render Ê™¢Ê∏¨Á´ØÂè£"""
    app = web.Application()
    app.router.add_get('/', health_check)
    app.router.add_get('/health', health_check)
    
    runner = web.AppRunner(app)
    await runner.setup()
    
    # Render ÊúÉËá™ÂãïÊèê‰æõ PORT Áí∞Â¢ÉËÆäÊï∏
    port = int(os.environ.get('PORT', 8080))
    site = web.TCPSite(runner, '0.0.0.0', port)
    await site.start()
    print(f"‚úÖ HTTP health server started on port {port}")
    
    return site
# ============================================================

async def post_init(application: Application):
    print("üìã Setting up bot commands...")
    await setup_commands(application)
    print("‚úÖ Bot commands setup complete")

def main():
    print("ü§ñ ÂïüÂãï‰∏≠...")
    print(f"Token: {TELEGRAM_TOKEN[:10]}...")
    
    # ÂïüÂãï HTTP ÂÅ•Â∫∑Ê™¢Êü•‰º∫ÊúçÂô®ÔºàÁî®Êñº Render Á´ØÂè£Ê™¢Ê∏¨Ôºâ
    loop = asyncio.new_event_loop()
    asyncio.set_event_loop(loop)
    loop.run_until_complete(start_health_server())
    
    application = Application.builder().token(TELEGRAM_TOKEN).post_init(post_init).build()
    
    add_handler = ConversationHandler(
        entry_points=[CommandHandler('add', add_start)],
        states={
            ADD_ADDRESS: [MessageHandler(filters.TEXT & ~filters.COMMAND, add_address)],
            ADD_NAME: [MessageHandler(filters.TEXT & ~filters.COMMAND, add_name)],
        },
        fallbacks=[CommandHandler('cancel', add_cancel)],
    )
    
    batch_add_handler = ConversationHandler(
        entry_points=[CommandHandler('batchadd', batch_add_start)],
        states={
            BATCH_ADD_DATA: [MessageHandler(filters.TEXT & ~filters.COMMAND, batch_add_data)],
        },
        fallbacks=[CommandHandler('cancel', batch_add_cancel)],
    )
    
    add_x_handler = ConversationHandler(
        entry_points=[CommandHandler('addx', add_x_start)],
        states={
            ADD_X: [MessageHandler(filters.TEXT & ~filters.COMMAND, add_x_account)],
        },
        fallbacks=[CommandHandler('cancel', add_x_cancel)],
    )
    
    application.add_handler(CommandHandler("start", start))
    application.add_handler(CommandHandler("test", test_api))
    application.add_handler(CommandHandler("checktether", check_tether))
    application.add_handler(CommandHandler("checkmexc", check_mexc))
    application.add_handler(add_handler)
    application.add_handler(CommandHandler("remove", remove_whale))
    application.add_handler(batch_add_handler)
    application.add_handler(CommandHandler("batchremove", batch_remove))
    application.add_handler(CommandHandler("list", list_whales))
    application.add_handler(CommandHandler("whalecheck", whale_check))
    application.add_handler(CommandHandler("allwhale", show_all_positions))
    application.add_handler(add_x_handler)
    application.add_handler(CommandHandler("removex", remove_x))
    application.add_handler(CommandHandler("listx", list_x))
    application.add_handler(CommandHandler("testx", test_x))
    application.add_handler(CallbackQueryHandler(button_callback))
    
    application.add_error_handler(error_handler)
    
    job_queue = application.job_queue
    if job_queue:
        job_queue.run_repeating(auto_update, interval=60, first=10)
        job_queue.run_repeating(tether_update, interval=300, first=30)
        job_queue.run_repeating(x_update, interval=120, first=20)
        job_queue.run_repeating(mexc_update, interval=180, first=40)
        print("‚úÖ ÂÆöÊôÇ‰ªªÂãôÂ∑≤Ë®≠ÁΩÆ")
    else:
        print("‚ö†Ô∏è Job queue Êú™ÂïüÁî®")
    
    print("‚úÖ Â∑≤ÂïüÂãï")
    application.run_polling(allowed_updates=Update.ALL_TYPES)

if __name__ == '__main__':
    main()